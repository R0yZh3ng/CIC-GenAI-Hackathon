Question,Answer,Difficulty,Topic
"Two Sum: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.","Use hash map to store complement values. For each number, check if target-num exists in map. Time: O(n), Space: O(n)","Easy","Arrays"
"Reverse Linked List: Given the head of a singly linked list, reverse the list and return the reversed list.","Iteratively reverse pointers: prev=None, while curr: next=curr.next, curr.next=prev, prev=curr, curr=next. Time: O(n), Space: O(1)","Easy","Linked Lists"
"Valid Parentheses: Given a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.","Use stack. Push opening brackets, pop and match closing brackets. Valid if stack empty at end. Time: O(n), Space: O(n)","Easy","Stack"
"Maximum Subarray: Given an integer array nums, find the contiguous subarray with the largest sum and return its sum.","Kadane's algorithm: max_sum = nums[0], current_sum = nums[0]. For each element, current_sum = max(num, current_sum + num). Time: O(n), Space: O(1)","Easy","Dynamic Programming"
"Merge Two Sorted Lists: Merge two sorted linked lists and return it as a sorted list.","Use two pointers, compare values and link smaller node. Handle remaining nodes. Time: O(m+n), Space: O(1)","Easy","Linked Lists"
"Best Time to Buy and Sell Stock: Given array of prices, find maximum profit from one transaction.","Track minimum price seen so far and maximum profit. profit = max(profit, price - min_price). Time: O(n), Space: O(1)","Easy","Arrays"
"Valid Palindrome: Given a string s, return true if it is a palindrome.","Two pointers from start and end, skip non-alphanumeric, compare characters ignoring case. Time: O(n), Space: O(1)","Easy","Two Pointers"
"Invert Binary Tree: Given the root of a binary tree, invert the tree and return its root.","Recursively swap left and right children for each node. Base case: if root is null return null. Time: O(n), Space: O(h)","Easy","Binary Tree"
"Binary Search: Given a sorted array nums and target value, return index of target or -1.","left=0, right=len-1. While left<=right: mid=(left+right)//2, compare nums[mid] with target. Time: O(log n), Space: O(1)","Easy","Binary Search"
"Climbing Stairs: You are climbing a staircase with n steps. Each time you can climb 1 or 2 steps. How many distinct ways?","Dynamic programming: dp[i] = dp[i-1] + dp[i-2]. Base cases: dp[1]=1, dp[2]=2. Time: O(n), Space: O(1)","Easy","Dynamic Programming"
"Longest Substring Without Repeating Characters: Find length of longest substring without repeating characters.","Sliding window with hash set. Expand window by moving right pointer, shrink by moving left when duplicate found. Time: O(n), Space: O(min(m,n))","Medium","Sliding Window"
"Add Two Numbers: Add two numbers represented as linked lists and return sum as linked list.","Traverse both lists simultaneously, handle carry. Create new nodes for result. Time: O(max(m,n)), Space: O(max(m,n))","Medium","Linked Lists"
"3Sum: Given array nums, return all unique triplets that sum to zero.","Sort array, use three pointers. Fix first element, use two pointers for remaining. Skip duplicates. Time: O(n²), Space: O(1)","Medium","Two Pointers"
"Container With Most Water: Find two lines that form container holding most water.","Two pointers at start and end. Move pointer with smaller height inward. Track maximum area. Time: O(n), Space: O(1)","Medium","Two Pointers"
"Group Anagrams: Given array of strings, group anagrams together.","Use sorted string as key in hash map. Group strings with same sorted key. Time: O(n*k*log k), Space: O(n*k)","Medium","Hash Table"
"Valid Sudoku: Determine if 9x9 Sudoku board is valid.","Use hash sets to track seen numbers in rows, columns, and 3x3 boxes. Check duplicates. Time: O(1), Space: O(1)","Medium","Hash Table"
"Search in Rotated Sorted Array: Search target in rotated sorted array.","Modified binary search. Determine which half is sorted, then check if target is in that range. Time: O(log n), Space: O(1)","Medium","Binary Search"
"Find Minimum in Rotated Sorted Array: Find minimum element in rotated sorted array.","Binary search. If nums[mid] > nums[right], minimum is in right half, else in left half. Time: O(log n), Space: O(1)","Medium","Binary Search"
"Kth Largest Element in Array: Find kth largest element in unsorted array.","Use quickselect algorithm or min heap of size k. Quickselect average O(n), heap O(n log k)","Medium","Heap"
"Top K Frequent Elements: Given array, return k most frequent elements.","Use hash map for frequency, then min heap or bucket sort. Time: O(n log k), Space: O(n)","Medium","Heap"
"Merge Intervals: Given array of intervals, merge overlapping intervals.","Sort intervals by start time. Merge overlapping intervals by comparing end times. Time: O(n log n), Space: O(1)","Medium","Intervals"
"Insert Interval: Insert new interval into sorted non-overlapping intervals.","Find position to insert, merge overlapping intervals on left and right. Time: O(n), Space: O(1)","Medium","Intervals"
"Rotate Image: Rotate n×n 2D matrix by 90 degrees clockwise in-place.","Transpose matrix (swap matrix[i][j] with matrix[j][i]), then reverse each row. Time: O(n²), Space: O(1)","Medium","Matrix"
"Spiral Matrix: Return all elements of matrix in spiral order.","Use four boundaries (top, bottom, left, right) and move in spiral pattern. Time: O(m*n), Space: O(1)","Medium","Matrix"
"Jump Game: Given array where each element represents max jump length, determine if you can reach last index.","Greedy approach: track farthest reachable position. If current index > farthest, return false. Time: O(n), Space: O(1)","Medium","Greedy"
"Unique Paths: Robot moves from top-left to bottom-right in m×n grid. How many unique paths?","Dynamic programming: dp[i][j] = dp[i-1][j] + dp[i][j-1]. Time: O(m*n), Space: O(m*n) or O(n)","Medium","Dynamic Programming"
"Coin Change: Find minimum coins needed to make amount using given coin denominations.","Dynamic programming: dp[i] = min(dp[i], dp[i-coin] + 1) for each coin. Time: O(amount * coins), Space: O(amount)","Medium","Dynamic Programming"
"Longest Increasing Subsequence: Find length of longest strictly increasing subsequence.","Dynamic programming with binary search. Use tails array to track smallest tail for each length. Time: O(n log n), Space: O(n)","Medium","Dynamic Programming"
"House Robber: Rob houses to maximize money without robbing adjacent houses.","Dynamic programming: dp[i] = max(dp[i-1], dp[i-2] + nums[i]). Time: O(n), Space: O(1)","Medium","Dynamic Programming"
"Product of Array Except Self: Return array where output[i] equals product of all elements except nums[i].","Two passes: left products, then right products. Avoid division. Time: O(n), Space: O(1)","Medium","Arrays"
"Maximum Product Subarray: Find contiguous subarray with largest product.","Track both max and min products (for negative numbers). Time: O(n), Space: O(1)","Medium","Dynamic Programming"
"Find Peak Element: Find peak element in array where nums[i] > nums[i-1] and nums[i] > nums[i+1].","Binary search: if nums[mid] < nums[mid+1], peak is on right, else on left. Time: O(log n), Space: O(1)","Medium","Binary Search"
"Search 2D Matrix: Search target in m×n matrix where each row and column is sorted.","Start from top-right corner. If target < current, move left. If target > current, move down. Time: O(m+n), Space: O(1)","Medium","Matrix"
"Set Matrix Zeroes: Set entire row and column to 0 if element is 0.","Use first row and column as markers. Handle first row/column separately. Time: O(m*n), Space: O(1)","Medium","Matrix"
"Minimum Window Substring: Find minimum window substring containing all characters of string t.","Sliding window with hash maps. Expand window until valid, then contract to find minimum. Time: O(s+t), Space: O(s+t)","Hard","Sliding Window"
"Trapping Rain Water: Calculate how much water can be trapped after raining.","Two pointers approach. Track max height from left and right. Water level = min(left_max, right_max). Time: O(n), Space: O(1)","Hard","Two Pointers"
"Median of Two Sorted Arrays: Find median of two sorted arrays.","Binary search on smaller array. Partition arrays such that left half ≤ right half. Time: O(log(min(m,n))), Space: O(1)","Hard","Binary Search"
"Merge k Sorted Lists: Merge k sorted linked lists and return as one sorted list.","Use min heap or divide and conquer. Heap: Time O(n log k), D&C: Time O(n log k), Space O(log k)","Hard","Heap"
"Largest Rectangle in Histogram: Find area of largest rectangle in histogram.","Use stack to store indices. For each bar, pop smaller bars and calculate area. Time: O(n), Space: O(n)","Hard","Stack"
"Sliding Window Maximum: Find maximum in each sliding window of size k.","Use deque to store indices in decreasing order of values. Time: O(n), Space: O(k)","Hard","Sliding Window"
"Edit Distance: Find minimum operations to convert word1 to word2.","Dynamic programming: dp[i][j] = min(insert, delete, replace). Time: O(m*n), Space: O(m*n)","Hard","Dynamic Programming"
"Regular Expression Matching: Implement regex matching with '.' and '*'.","Dynamic programming: handle '.' as any character, '*' as zero or more of preceding. Time: O(m*n), Space: O(m*n)","Hard","Dynamic Programming"
"Wildcard Matching: Implement wildcard matching with '?' and '*'.","Dynamic programming: '?' matches any single character, '*' matches any sequence. Time: O(m*n), Space: O(m*n)","Hard","Dynamic Programming"
"Longest Valid Parentheses: Find length of longest valid parentheses substring.","Use stack to store indices or dynamic programming. Track valid parentheses positions. Time: O(n), Space: O(n)","Hard","Stack"
"First Missing Positive: Find smallest missing positive integer.","Place each number at its correct position (nums[i] should be at index i-1). Time: O(n), Space: O(1)","Hard","Arrays"
"N-Queens: Place n queens on n×n chessboard so no two queens attack each other.","Backtracking with constraint checking. Use arrays to track column and diagonal conflicts. Time: O(n!), Space: O(n)","Hard","Backtracking"
"Word Ladder: Find shortest transformation sequence from beginWord to endWord.","BFS with word transformations. Each step changes one character. Time: O(m²*n), Space: O(m²*n)","Hard","BFS"
"Alien Dictionary: Find order of characters in alien language from sorted words.","Topological sort. Build graph from character order constraints. Time: O(c), Space: O(1) where c is total characters","Hard","Topological Sort"
"Course Schedule: Determine if you can finish all courses given prerequisites.","Detect cycle in directed graph using DFS or topological sort with BFS. Time: O(v+e), Space: O(v+e)","Medium","Graph"
"Number of Islands: Count number of islands in 2D binary grid.","DFS or BFS to mark connected land cells. Count number of DFS/BFS calls. Time: O(m*n), Space: O(m*n)","Medium","DFS"
"Clone Graph: Return deep copy of undirected graph.","DFS or BFS with hash map to track visited nodes and their clones. Time: O(n+m), Space: O(n)","Medium","Graph"
"Pacific Atlantic Water Flow: Find cells where water can flow to both Pacific and Atlantic oceans.","DFS from ocean borders inward. Find intersection of reachable cells. Time: O(m*n), Space: O(m*n)","Medium","DFS"
"Word Search: Find if word exists in 2D board of characters.","DFS with backtracking. Mark visited cells and unmark after exploring. Time: O(m*n*4^l), Space: O(l)","Medium","Backtracking"
"Combination Sum: Find all unique combinations that sum to target.","Backtracking with recursion. Include/exclude each candidate. Handle duplicates. Time: O(2^n), Space: O(target/min)","Medium","Backtracking"
"Permutations: Generate all possible permutations of distinct integers.","Backtracking by swapping elements or using visited array. Time: O(n!), Space: O(n)","Medium","Backtracking"
"Subsets: Generate all possible subsets of integer array.","Backtracking or bit manipulation. For each element, include or exclude. Time: O(2^n), Space: O(2^n)","Medium","Backtracking"
"Generate Parentheses: Generate all combinations of well-formed parentheses.","Backtracking with constraints: open < n and close < open. Time: O(4^n/√n), Space: O(4^n/√n)","Medium","Backtracking"
"Letter Combinations of Phone Number: Return all possible letter combinations for phone number.","Backtracking through digit-to-letter mapping. Time: O(4^n), Space: O(4^n)","Medium","Backtracking"
"Palindromic Substrings: Count number of palindromic substrings.","Expand around centers approach. Check odd and even length palindromes. Time: O(n²), Space: O(1)","Medium","String"
"Longest Palindromic Substring: Find longest palindromic substring.","Expand around centers or Manacher's algorithm. Time: O(n²) or O(n), Space: O(1) or O(n)","Medium","String"
"Valid Anagram: Determine if two strings are anagrams.","Sort both strings and compare, or use character frequency count. Time: O(n log n) or O(n), Space: O(1)","Easy","String"
"Implement Trie: Implement trie data structure with insert, search, and startsWith.","Use TrieNode with children array and isEnd flag. Time: O(m) for operations, Space: O(alphabet_size * n * m)","Medium","Trie"
"Word Search II: Find all words from dictionary that exist in 2D board.","Build trie from dictionary, then DFS on board with trie traversal. Time: O(m*n*4^l), Space: O(k*l)","Hard","Trie"
"Design Add and Search Words Data Structure: Support adding words and searching with '.' wildcard.","Use trie with DFS for wildcard search. Time: O(m) for add, O(n) for search, Space: O(alphabet_size * n * m)","Medium","Trie"
"Serialize and Deserialize Binary Tree: Design algorithm to serialize and deserialize binary tree.","Use preorder traversal with null markers. Time: O(n), Space: O(n)","Hard","Binary Tree"
"Binary Tree Maximum Path Sum: Find maximum path sum in binary tree.","Post-order traversal, track max path through each node. Time: O(n), Space: O(h)","Hard","Binary Tree"
"Lowest Common Ancestor of Binary Tree: Find LCA of two nodes in binary tree.","Recursive approach: if root is p or q, return root. Check left and right subtrees. Time: O(n), Space: O(h)","Medium","Binary Tree"
"Binary Tree Level Order Traversal: Return level order traversal of binary tree.","BFS using queue. Process nodes level by level. Time: O(n), Space: O(w) where w is max width","Medium","BFS"
"Binary Tree Zigzag Level Order Traversal: Return zigzag level order traversal.","BFS with alternating direction flag or use two stacks. Time: O(n), Space: O(w)","Medium","BFS"
"Construct Binary Tree from Preorder and Inorder: Build binary tree from preorder and inorder arrays.","Use preorder for root, inorder to split left/right subtrees. Time: O(n), Space: O(n)","Medium","Binary Tree"
"Validate Binary Search Tree: Determine if binary tree is valid BST.","In-order traversal should be sorted, or use min/max bounds. Time: O(n), Space: O(h)","Medium","Binary Tree"
"Kth Smallest Element in BST: Find kth smallest element in BST.","In-order traversal with counter or use BST property with node counts. Time: O(h+k), Space: O(h)","Medium","Binary Tree"
"Delete Node in BST: Delete node with given key in BST.","Handle three cases: no children, one child, two children. Time: O(h), Space: O(h)","Medium","Binary Tree"
"Implement LRU Cache: Design LRU cache with get and put operations.","Use doubly linked list + hash map. Time: O(1) for both operations, Space: O(capacity)","Medium","Design"
"Min Stack: Design stack supporting push, pop, top, and getMin in O(1).","Use two stacks: main stack and min stack. Time: O(1) for all operations, Space: O(n)","Easy","Design"
"Design Twitter: Design simplified Twitter with postTweet, getNewsFeed, follow, unfollow.","Use hash maps for users, tweets, and follows. Merge k sorted lists for news feed. Time varies by operation","Medium","Design"
"LFU Cache: Design LFU cache with get and put operations.","Use hash maps and doubly linked lists to track frequency and recency. Time: O(1), Space: O(capacity)","Hard","Design"
"Design Search Autocomplete System: Design search autocomplete system.","Use trie for storing sentences with frequency. Return top 3 hot sentences. Time: O(p+q+mlogm), Space: O(n*m)","Hard","Design"
"Meeting Rooms: Determine if person can attend all meetings given array of meeting intervals.","Sort intervals by start time, check for overlaps. Time: O(n log n), Space: O(1)","Easy","Intervals"
"Meeting Rooms II: Find minimum number of conference rooms required.","Use min heap to track end times of ongoing meetings. Time: O(n log n), Space: O(n)","Medium","Intervals"
"Non-overlapping Intervals: Find minimum number of intervals to remove to make rest non-overlapping.","Greedy: sort by end time, keep intervals with earliest end time. Time: O(n log n), Space: O(1)","Medium","Intervals"
"Minimum Number of Arrows to Burst Balloons: Find minimum arrows needed to burst all balloons.","Sort by end coordinate, shoot arrow at end of each group. Time: O(n log n), Space: O(1)","Medium","Intervals"
"Task Scheduler: Find minimum time to execute all tasks with cooling period.","Calculate idle time based on most frequent task. Time: O(n), Space: O(1)","Medium","Greedy"
"Gas Station: Find starting gas station to complete circular route.","Track total gas and current gas. If total >= 0, solution exists. Time: O(n), Space: O(1)","Medium","Greedy"
"Candy: Distribute minimum candies to children based on ratings.","Two passes: left to right for increasing ratings, right to left for decreasing. Time: O(n), Space: O(n)","Hard","Greedy"
"Queue Reconstruction by Height: Reconstruct queue based on height and number of taller people.","Sort by height desc, then by count asc. Insert at count position. Time: O(n²), Space: O(n)","Medium","Greedy"
"Partition Labels: Partition string into as many parts as possible where each letter appears in at most one part.","Track last occurrence of each character, extend partition to include all characters. Time: O(n), Space: O(1)","Medium","Greedy"
"Hand of Straights: Determine if cards can be rearranged into groups of consecutive cards.","Use hash map to count cards, greedy approach to form groups. Time: O(n log n), Space: O(n)","Medium","Greedy"
"Reorganize String: Rearrange string so no two adjacent characters are same.","Use max heap based on character frequency. Time: O(n log k), Space: O(k)","Medium","Heap"
"Find Median from Data Stream: Design data structure to find median from stream of integers.","Use two heaps: max heap for smaller half, min heap for larger half. Time: O(log n), Space: O(n)","Hard","Heap"
"Sliding Window Median: Find median of each sliding window of size k.","Use two multisets or balanced BST. Time: O(n log k), Space: O(k)","Hard","Sliding Window"
"Smallest Range Covering Elements from K Lists: Find smallest range that includes at least one number from each list.","Use min heap with pointers to each list. Time: O(n log k), Space: O(k)","Hard","Heap"
"Ugly Number II: Find nth ugly number (only factors 2, 3, 5).","Use three pointers for multiples of 2, 3, 5. Generate ugly numbers in order. Time: O(n), Space: O(n)","Medium","Dynamic Programming"
"Super Ugly Number: Find nth super ugly number given array of prime factors.","Extend ugly number approach with multiple prime factors. Time: O(n*k), Space: O(n+k)","Medium","Dynamic Programming"
"Perfect Squares: Find least number of perfect squares that sum to n.","Dynamic programming or BFS. dp[i] = min(dp[i], dp[i-j*j] + 1). Time: O(n*√n), Space: O(n)","Medium","Dynamic Programming"
"Counting Bits: Count number of 1s in binary representation for numbers 0 to n.","Use DP: dp[i] = dp[i >> 1] + (i & 1). Time: O(n), Space: O(n)","Easy","Bit Manipulation"
"Number of 1 Bits: Count number of 1 bits in unsigned integer.","Use bit manipulation: n & (n-1) removes rightmost 1 bit. Time: O(log n), Space: O(1)","Easy","Bit Manipulation"
"Reverse Bits: Reverse bits of 32-bit unsigned integer.","Process each bit and build result from right to left. Time: O(1), Space: O(1)","Easy","Bit Manipulation"
"Single Number: Find element that appears once while others appear twice.","Use XOR operation: a ^ a = 0, a ^ 0 = a. Time: O(n), Space: O(1)","Easy","Bit Manipulation"
"Single Number II: Find element that appears once while others appear thrice.","Use bit manipulation with counters or XOR with state machine. Time: O(n), Space: O(1)","Medium","Bit Manipulation"
"Single Number III: Find two elements that appear once while others appear twice.","XOR all numbers, then separate into two groups based on rightmost set bit. Time: O(n), Space: O(1)","Medium","Bit Manipulation"
"Missing Number: Find missing number in array containing n distinct numbers from 0 to n.","Use XOR, sum formula, or binary search. Time: O(n), Space: O(1)","Easy","Bit Manipulation"
"Power of Two: Determine if integer is power of two.","Use bit manipulation: n > 0 && (n & (n-1)) == 0. Time: O(1), Space: O(1)","Easy","Bit Manipulation"
"Power of Three: Determine if integer is power of three.","Use logarithm or check if 3^19 % n == 0 (since 3^19 is largest power of 3 in 32-bit). Time: O(1), Space: O(1)","Easy","Math"
"Power of Four: Determine if integer is power of four.","Check if power of two and (n-1) % 3 == 0, or use bit pattern. Time: O(1), Space: O(1)","Easy","Bit Manipulation"